// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

.assembly extern mscorlib { }

.assembly HelloWasm.IL { }

.class public CpObj.CpObjTest
{
  .method public hidebysig static void CpObj(valuetype CpObj.TestValue& dest, valuetype CpObj.TestValue& src)
  {
    ldarg.0
    ldarg.1
    cpobj CpObj.TestValue
    ret
  }
}

.class public value sealed CpObj.TestValue
{
  .field public int32 Field;
}

.class public abstract sealed CkFinite.CkFiniteTest
{
  .method public static bool CkFinite32(float32)
  {
    .maxstack 5
    try_start:
      ldarg 0
      ckfinite
      pop   //remove the value from the stack
      leave try_end
    try_end:
      ldc.i4 0x00000001
      ret
    handler_start:
      pop //remove the exception ref from the stack
      leave done
    handler_end:
    done:
      ldc.i4 0x00000000
      ret
    .try try_start to try_end catch [mscorlib]System.OverflowException handler handler_start to handler_end
  }

  .method public static bool CkFinite64(float64)
  {
    .maxstack 5
    try_start:
      ldarg 0
      ckfinite
      pop //remove the value from the stack
      leave try_end
    try_end:
      ldc.i4 0x00000001
      ret
    handler_start:
      pop //remove the exception ref from the stack
      leave done
    handler_end:
    done:
      ldc.i4 0x00000000
      ret
    .try try_start to try_end catch [mscorlib]System.OverflowException handler handler_start to handler_end
  }
}

.typedef [mscorlib]System.ICloneable as ICloneable

.class public ILHelpers.ILHelpersTest
{
  // RVA static field
  .field public static int32 StaticInitedInt at D_00004000
  .data D_00004000 = bytearray (12 34 56 78)

  .method public static void EatArgs(string, object)
  {
    ret
  }

  .method public static void EatArg(object)
  {
    ret
  }

  // This is copied from the test case for https://github.com/dotnet/runtime/issues/9210.
  .method public static int32 InlineAssignByte()
  {
    .locals init (
      int8 local,
      object b
    )
    ldstr "InlineAssignByte"
    ldc.i4 300
    dup
    stloc.0
    box int32
    stloc.1
    ldloc.1
    call void ILHelpers.ILHelpersTest::EatArgs(string, object)
    ldstr "InlineAssignByte"
    ldloc.0
    box int32
    call void ILHelpers.ILHelpersTest::EatArgs(string, object)
    ldloc.1
    //after the unboxing and truncation on the way in ensure that we can subtract 200 and end up with the expected 100 return value
    unbox.any int32
    ldc.i4 200
    sub
    ret
  }
  .method public static int32 DupTest(int32&)
  {
    .locals init (
      int32 local,
      int32 local2
    )
    ldarg.0
    //push a bunch of entries onto the stack using dup, we will consume them through the rest of this method
    dup
    dup
    dup
    dup
    dup
    //first off lets ensure the passed parameter was pointing to an int of less than 10 (it should be 9)
    ldind.i4
    ldc.i4 10
    clt
    brtrue target
    //this is just trying to mess with the stack accross basic block boundries
    //it should actually leave the evaluation stack unchanged in the end
    pop
    dup
    //make sure we can deref one of our duplicate int refs and box it without any trouble
    target: ldind.i4
    box int32
    call void ILHelpers.ILHelpersTest::EatArg(object)
    //deref one of our duplicates and add 1 to it, this should not write back to the parameter it should only be stored in the local
    ldind.i4 
    ldc.i4 1
    add
    stloc.0
    //load one of our duplicates and add 200 to it, we're eventually going to return this value and test for it in the caller
    ldind.i4
    ldc.i4 200
    add
    //this should write back into the parameter
    stind.i4
    ldloc.0
    dup
    add
    dup
    stloc.1
    ldloc.0
    ceq
    //if the added value equals the source value we've got something writing to its original StackEntry instead of a dup
    brtrue failure
    ldind.i4
    ret
    failure:
    pop
    ldc.i4 0
    ret
  }

  .method public static bool BneSbyteExtend()
  {
    // Method begins at RVA 0x2050
    // Code size 8 (0x8)
    .maxstack 8

    .locals init (
        [0] int8
    )

    ldc.i4.m1
    stloc.0
    ldloc.0
    ldc.i4.m1
    bne.un.s failure

    ldc.i4.1
    ret

    failure:
    ldc.i4.0
    ret
  }

  .method public static int32 TestLdTokenMethod(int32)
  {
    ldarg.0
    ret
  }

  .method public static object LdMethodToken()
  {
    ldtoken method int32 ILHelpers.ILHelpersTest::TestLdTokenMethod(int32)
    call class [mscorlib]System.Reflection.MethodBase [mscorlib]System.Reflection.MethodBase::GetMethodFromHandle(valuetype [mscorlib]System.RuntimeMethodHandle)
    ret
  }

  .method public static bool TestLdvirtftnVTable(object obj)
  {
    ldarg obj
    ldarg obj
    call void* .this::GetToStringFunctionPointer(object)
    calli instance string()
    ldarg obj
    callvirt instance string object::ToString()
    call bool string::Equals(string, string)
    ret
  }

  .method private static void* GetToStringFunctionPointer(object obj) noinlining
  {
    ldarg obj
    ldvirtftn instance string object::ToString()
    ret
  }

  .method public static bool TestLdvirtftnInterface(class ICloneable obj)
  {
    ldarg obj
    ldarg obj
    call void* .this::GetCloneFunctionPointer(class ICloneable)
    calli instance object()
    ldarg obj
    callvirt instance object ICloneable::Clone()
    ceq
    ret
  }

  .method private static void* GetCloneFunctionPointer(class ICloneable obj) noinlining
  {
    ldarg obj
    ldvirtftn instance object ICloneable::Clone()
    ret
  }
}
