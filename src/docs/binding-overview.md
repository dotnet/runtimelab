# Overview of Binding

Binding is the process of making Swift code available to C#. This means being able to access Swift types from C# as well as being able to make a set of C# types available to Swift. In this process there are a number of things that need to be taken into consideration:
- Language parity mismatches
- ABI (application binary interface) mismatches
- Runtime differences
- Idiomatic differences
- Accessibility

## Language Parity Mismatches
Swift is a hybrid programming language leaning towards functional. It has all the features that you would expect in a traditional object oriented programming language, but from Apple's point of view, these are not features that are encouraged. Instead, Apple is encouraging using value types for most everything using copy-on-write semantics for the collection types. In fact, the main runtime for swift, swiftCore, contains 0 published classes as of a few years ago. In addition, Apple encourages "aspect oriented" rather than object oriented coding.

In addition, Swift has a number of language features that do not exist in C#:
- Discriminated Unions - Swift enums are built so that any case in the set may have payloads and the payloads need not be the same type
- Actors - Swift has a flavor of heap-allocated types called Actors. There are largely syntactic sugar onto a non-virtual class, but there are
restrictions generated by the compiler to effectively give an implicit lock.
- Protocols with Associated Types (PATs) - these are a way of expressing recursive relations in generic interfaces in a less complicated way. One thing to keep in mind with PATs is that they are not actual types but rather a set of traits that types can adopt.
- Protocol list types - this is a similar to having multiple interface constraints on a generic.
- `some` - this is a two-purpose keyword. When used to modify an argument type this is syntactic sugar for an implicitly generic argument with a protocol constraint. When used to modify a return type, it represents a generic type whose provenance is owned by the caller instead of the callee
- In calling a function that throws, the callee must either handle the error or declare that it rethrows
- Naming - Swift allows all manner of unicode characters in function and operator names and the results are not pronounceable in C#
- Homonyms - Swift allows functions to have identical names and arguments, but differ only in return type
- Operators - Swift allows much more flexibility in defining operators than C#
- Failable constructors - Swift allows constructors to be defined as `init?()` which will return `nil` on failure
- Swift has only 1 namespace, the module name, with no nesting.
- Swift has top level entities, i.e., global functions and variables.
- In Swift, all members in a type *must* be initialized. Similarly, unsafe pointer types have a notion of 4 possible states that they can be in:
  - allocated
  - initialized
  - deinitialized
  - deallocated
Effectively, all types follow this pattern, but the 4 states are managed by the compiler and the runtime and unlike pointer types, there is no explicit control of it.

## ABI Differences
There are [a number of changes that Apple made outside of the standard ABIs](https://github.com/swiftlang/swift/blob/main/docs/ABI/CallingConvention.rst) used for target CPUs that are important to keep in mind:
- For value types, they allow more registers to be used for passing the type.
- For instance methods and closures, there is a separate register reserved outside of the regular argument registers used for passing the instance pointer
- For functions that throw, there is a separate register reserved for exceptions (errors)
- For returning value types an extra register is available
- For async methods, there is a separate register for the async context

## Runtime Differences
The main difference in the Swift runtime is that heap allocated types are reference counted rather than using another memory management scheme. The reference counting is not done with a single count but instead is managed with two counts: a strong count and a weak count. Weak references are available in Swift for making (potentially) circular data structures.

## Idiomatic Differences
For the most part, these are minor. C# prefers camel case starting with a capital letter for all types and entry points, using lowercase starts for private fields and argument names. C# adopts that conventions that interfaces start with 'I'. Swift starts types with capitals but public variables will start with lowercase.

Swift favors value types over heap allocated types and favors copy-on-write semantics.

For bit fields, C# prefers using enums with the `[Flags]` attribute. In Swift, the pattern is to use a struct that implements `OptionSet`.

## Accessibility
First and foremost, our customers matter the most. They are the ones who will be using the code and everything they use should "feel" like C# to them rather than Swift. As much as possible, this should be automated.

That said, there will be hard choices that need to be made. For example, consider the following Swift function:
```swift
public func VowelCount(text: String) -> Int { /* ... */ }
```
`String` in Swift is a vastly different and completely incompatible type from a C# string. In C# a string is an array of UTF16 characters. In Swift, the layout of `String` is completely different. It is a union of several different possible representations. As such, it is always the case that when you want to make a Swift string accessible in C# you will need to allocate memory. Similarly, when you want a C# string accessible in Swift, you will need to allocate memory. Consequently, you have to care about the memory lifetime of the object.

So there are two ways we can think of how to surface this function in C#:
```csharp
public nint VowelCount(string text) { /* ... */ }
public nint VowelCount(SwiftString text) { /* ... */}
```
The first seems to be the most natural way to expose this, but it creates problems. Consider this snippet of code:
```csharp
nint sum = 0;
for (int i=0; i < 200; i++) {
  sum += VowelCount("sphinx of black quartz judge my vow.");
}
```
The problem here is that `VowelCount` will do 400 allocations and deallocations (once for a buffer to hold UTF8 and once for the final Swift string per time through the loop). Furthermore, there is no way to make this any better and the method hides the expense giving the illusion that it's free.

The second approach is to require the user to handle the conversion, which can be done like this:
```csharp
nint sum = 0;
for (int i=0; i< 200 i++) {
  // use explicit conversion method
  sum += VowelCount((SwiftString)"spinx of black quartz judge my vow"); // don't do this - accumulates memory that needs to be garbage collected
}
using var str = (SwiftString)"spinx of black quartz judge my vow";
for (int i=0; i< 200 i++) {
  sum += VowelCount(str); // better - now only 2 allocations
}
```
Likely the best way to handle this is to bind function automatically to take a `SwiftString` as an argument and to create a partial class for the
convenience methods.

To keep things organized, each of the separate language features are broken out into their own document.

- [functions](binding-functions.md)
- [variables](binding-variables.md)
- [classes](binding-classes.md)
- actors
- [structs](binding-structs.md)
- [enums](binding-enums.md)
- [tuples](binding-tuples.md)
- [protocols](binding-protocols.md)
- protocols with associated types
- [closures] (binding-closures.md)





