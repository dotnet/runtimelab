using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.DotnetRuntime.Extensions;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;

namespace System.IO.StreamSourceGeneration;

[Generator]
public partial class StreamSourceGen : IIncrementalGenerator
{
    private const string StreamBoilerplateAttributeFullName = "System.IO.StreamSourceGeneration.GenerateStreamBoilerplateAttribute";
    private const string StreamFullName = "System.IO.Stream";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            //Debugger.Launch();
            ctx.AddSource("TaskToApm.g.cs", System.IO.StreamSourceGeneration.Properties.Resources.TaskToApm);
        });

        IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                StreamBoilerplateAttributeFullName,
                predicate: (node, _) => node is ClassDeclarationSyntax c && c.Modifiers.Any(SyntaxKind.PartialKeyword),
                transform: (context, _) => (ClassDeclarationSyntax)context.TargetNode);

        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
            context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        //Debugger.Launch();

        List<GenerationOptions>? classesWithGenerationOptions = GetClassesWithGenerationOptions(compilation, classes, context.CancellationToken);

        if (classesWithGenerationOptions == null)
        {
            return;
        }

        StringBuilder sb = new();

        foreach (GenerationOptions generationOptions in classesWithGenerationOptions)
        {
            sb.Clear();
            Emit(sb, generationOptions);

            INamedTypeSymbol classSymbol = generationOptions.ClassSymbol;
            string hintName = $"{classSymbol.ContainingNamespace}.{classSymbol.Name}.Boilerplate.g.cs";
            context.AddSource(hintName, sb.ToString());
        }
    }

    private static void Emit(StringBuilder sb, GenerationOptions generationOptions)
    {
        sb.Append($@"// <auto-generated/>

#nullable enable

using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace {generationOptions.ClassSymbol.ContainingNamespace}
{{");
        sb.Append($@"
    partial class {generationOptions.ClassSymbol.Name}
    {{");

        // First, Emit the boilerplate for all members that require it, unless they are already overridden/implemented.
        StreamOperation neededCoreMethods = EmitBoilerplates(sb, generationOptions, GetOverriddenMembers(generationOptions.ClassSymbol.GetMembers()));

        // Second, emit partial Core methods, unless the dependent boilerplate wasn't emitted.
        EmitPartials(sb, neededCoreMethods);

        sb.Append(StreamBoilerplateConstants.Helpers);
        sb.Append(@"
    }
}
");
    }

    static StreamOperation EmitBoilerplates(StringBuilder sb, GenerationOptions options, IEnumerable<string> overriddenMembers)
    {
        StreamOperation neededCoreMethods = StreamOperation.None;

        foreach (BoilerplateCandidateInfo candidate in BoilerplateCandidateInfo.s_boilerplateGenerationCandidates) // need to have the already compiled boilerplate source and have a dictionary where the key is the ToDisplayName of each member.
        {
            if (overriddenMembers.Contains(candidate.Name))
            {
                continue;
            }

            if (options.IsOptedIn(candidate.Operation))
            {
                sb.Append(candidate.Boilerplate);
                neededCoreMethods |= candidate.Operation;
            }
            else
            {
                sb.Append(candidate.BoilerplateForUnsupported);
            }
        }

        return neededCoreMethods;
    }

    static void EmitPartials(StringBuilder sb, StreamOperation neededCoreMethods)
    {
        if ((neededCoreMethods & StreamOperation.Read) != 0)
        {
            sb.Append(StreamBoilerplateConstants.ReadCore);
        }

        if ((neededCoreMethods & StreamOperation.Write) != 0)
        {
            sb.Append(StreamBoilerplateConstants.WriteCore);
        }

        if ((neededCoreMethods & StreamOperation.Seek) != 0)
        {
            sb.Append(StreamBoilerplateConstants.SeekCore);
        }

        if ((neededCoreMethods & StreamOperation.ReadAsync) != 0)
        {
            sb.Append(StreamBoilerplateConstants.ReadCoreAsync);
        }

        if ((neededCoreMethods & StreamOperation.WriteAsync) != 0)
        {
            sb.Append(StreamBoilerplateConstants.WriteCoreAsync);
        }

        if ((neededCoreMethods & StreamOperation.SetLength) != 0)
        {
            sb.Append(StreamBoilerplateConstants.SetLengthCore);
        }
    }

    private static IEnumerable<string> GetOverriddenMembers(ImmutableArray<ISymbol> members)
    {
        return members.Select(m => GetOverriddenMember(m)?.ToDisplayString()).Where(s => s != null)!;

        static ISymbol? GetOverriddenMember(ISymbol member)
            => member switch
            {
                IMethodSymbol method => method.OverriddenMethod,
                IPropertySymbol property => property.OverriddenProperty,
                _ => null
            };
    }

    private static List<GenerationOptions>? GetClassesWithGenerationOptions(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, CancellationToken cancellationToken)
    {
        INamedTypeSymbol? streamBoilerplateAttributeSymbol = compilation.GetBestTypeByMetadataName(StreamBoilerplateAttributeFullName);
        INamedTypeSymbol? streamSymbol = compilation.GetBestTypeByMetadataName(StreamFullName);

        if (streamBoilerplateAttributeSymbol == null ||
            streamSymbol == null)
        {
            return null;
        }

        List<GenerationOptions>? retVal = null;

        foreach (IGrouping<SyntaxTree, ClassDeclarationSyntax> group in classes.GroupBy(c => c.SyntaxTree))
        {
            SyntaxTree syntaxTree = group.Key;
            SemanticModel compilationSemanticModel = compilation.GetSemanticModel(syntaxTree);

            foreach (ClassDeclarationSyntax classNode in group)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (!DerivesFromStream(classNode, streamSymbol, compilationSemanticModel, cancellationToken))
                {
                    continue;
                }

                INamedTypeSymbol classSymbol = compilationSemanticModel.GetDeclaredSymbol(classNode, cancellationToken)!;

                //AttributeSyntax firstAttribute = classNode.AttributeLists.First().Attributes.First();
                foreach (AttributeListSyntax attributeListSyntax in classNode.AttributeLists)
                {
                    // TODO: test if this fails when type contains multiple attributes.
                    AttributeSyntax attributeSyntax = attributeListSyntax.Attributes.First();
                    IMethodSymbol? attributeSymbol = compilationSemanticModel.GetSymbolInfo(attributeSyntax, cancellationToken).Symbol as IMethodSymbol;

                    if (attributeSymbol == null || 
                        !streamBoilerplateAttributeSymbol.Equals(attributeSymbol.ContainingType, SymbolEqualityComparer.Default))
                    {
                        // badly formed attribute definition, or not the right attribute
                        continue;
                    }

                    var generationOptions = GetGenerationOptions(attributeSyntax, classSymbol);

                    retVal ??= new List<GenerationOptions>();
                    retVal.Add(generationOptions);
                }
            }
        }

        return retVal;
    }

    private static GenerationOptions GetGenerationOptions(AttributeSyntax attributeSyntax, INamedTypeSymbol classSymbol)
    {
        // Default values if the properties are unspecified.
        bool canRead = true, canWrite = true, canSeek = true;

        IEnumerable<SyntaxNode> attributeArguments = attributeSyntax.DescendantNodes().Where(node => node is AttributeArgumentSyntax);
        foreach (AttributeArgumentSyntax node in attributeArguments)
        {
            IEnumerable<SyntaxNode> childNodes = node.ChildNodes();
            NameEqualsSyntax propertyNameNode = (NameEqualsSyntax)childNodes.First();

            SyntaxNode? propertyValueNode = childNodes.ElementAtOrDefault(1);
            string propertyValueStr = propertyValueNode.GetLastToken().ValueText;
            
            switch (propertyNameNode.Name.Identifier.ValueText)
            {
                case nameof(GenerateStreamBoilerplateAttribute.CanRead):
                    bool.TryParse(propertyValueStr, out canRead);
                    break;

                case nameof(GenerateStreamBoilerplateAttribute.CanWrite):
                    bool.TryParse(propertyValueStr, out canWrite);
                    break;

                case nameof(GenerateStreamBoilerplateAttribute.CanSeek):
                    bool.TryParse(propertyValueStr, out canSeek);
                    break;
            }
        }

        return new GenerationOptions(canRead, canWrite, canSeek, classSymbol);
    }

    // TODO: merge this method with DerivesFromJsonSerializerContext.
    private static bool DerivesFromStream(
        ClassDeclarationSyntax classDeclarationSyntax,
        INamedTypeSymbol streamSymbol,
        SemanticModel compilationSemanticModel,
        CancellationToken cancellationToken)
    {
        SeparatedSyntaxList<BaseTypeSyntax>? baseTypeSyntaxList = classDeclarationSyntax.BaseList?.Types;
        if (baseTypeSyntaxList == null)
        {
            return false;
        }

        INamedTypeSymbol? match = null;

        foreach (BaseTypeSyntax baseTypeSyntax in baseTypeSyntaxList)
        {
            INamedTypeSymbol? candidate = compilationSemanticModel.GetSymbolInfo(baseTypeSyntax.Type, cancellationToken).Symbol as INamedTypeSymbol;
            if (candidate != null && streamSymbol.Equals(candidate, SymbolEqualityComparer.Default))
            {
                match = candidate;
                break;
            }
        }

        return match != null;
    }
}
