// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

using Internal.Runtime;

namespace System.Runtime
{
    internal static unsafe partial class EH
    {
        // The layout of this struct must match the native version in "Bootstrapper/main.cpp" exactly.
        [StructLayout(LayoutKind.Explicit)]
        private struct ManagedExceptionWrapper
        {
            // TODO-LLVM: update the field to be typed "object" once C#11 is available.
            // TODO-LLVM-EH: the way managed exception object is being passed inside the native exception is a GC hole.
            // Make this more robust, e. g. wrap it in a GCHandle.
            // TODO-LLVM: make the offset into a constant generated by the runtime build (ala AsmOffsets.cs).
            [FieldOffset(4)]
            public void* ManagedException;
        }

        // The layout of this struct must match what codegen expects (see "jit/llvmcodegen.cpp, generateEHDispatch").
        // Instances of it are shared between dispatchers across a single native frame.
        private struct DispatchData
        {
            public readonly CppExceptionTuple CppExceptionTuple; // Owned by codegen.
            public ManagedExceptionWrapper* DispatcherData; // Owned by runtime.

            // We consider a dispatch to be "active" if it has already visited nested handlers in the same LLVM frame.
            // Codegen will initialize "DispatcherData" to null on entry to the native handler.
            public bool Active => DispatcherData != null;
        }

        private struct CppExceptionTuple
        {
            public void* ExceptionData;
            public int Selector;
        }

        // These per-clause handlers are invoked by RyuJit-generated LLVM code.
        //
        private static int HandleExceptionWasmMutuallyProtectingCatches(void* pShadowFrame, DispatchData* pDispatchData, void** pEHTable)
        {
            object exception = BeginSingleDispatch(RhEHClauseKind.RH_EH_CLAUSE_UNUSED, pEHTable, pShadowFrame, pDispatchData);

            EHRyuJitClauseIteratorWasm clauseIter = new EHRyuJitClauseIteratorWasm(pEHTable);
            EHRyuJitClauseWasm clause;
            while (clauseIter.Next(&clause))
            {
                WasmEHLogEHTableEntry(clause, pShadowFrame);

                bool foundHandler = false;
                if (clause.Filter != null)
                {
                    if (CallFilterFunclet(clause.Filter, exception, pShadowFrame, ryuJitAbi: true))
                    {
                        foundHandler = true;
                    }
                }
                else
                {
                    if (ShouldTypedClauseCatchThisException(exception, clause.ClauseType))
                    {
                        foundHandler = true;
                    }
                }

                if (foundHandler)
                {
                    __cxa_end_catch();
                    return CallCatchFunclet(clause.Handler, exception, pShadowFrame);
                }
            }

            return DispatchContinueSearch(exception, pDispatchData);
        }

        private static int HandleExceptionWasmFilteredCatch(void* pShadowFrame, DispatchData* pDispatchData, void* pHandler, void* pFilter)
        {
            object exception = BeginSingleDispatch(RhEHClauseKind.RH_EH_CLAUSE_FILTER, null, pShadowFrame, pDispatchData);

            if (CallFilterFunclet(pFilter, exception, pShadowFrame, ryuJitAbi: true))
            {
                __cxa_end_catch();
                return CallCatchFunclet(pHandler, exception, pShadowFrame);
            }

            return DispatchContinueSearch(exception, pDispatchData);
        }

        private static int HandleExceptionWasmCatch(void* pShadowFrame, DispatchData* pDispatchData, void* pHandler, MethodTable* pClauseType)
        {
            object exception = BeginSingleDispatch(RhEHClauseKind.RH_EH_CLAUSE_TYPED, pClauseType, pShadowFrame, pDispatchData);

            if (ShouldTypedClauseCatchThisException(exception, pClauseType))
            {
                __cxa_end_catch();
                return CallCatchFunclet(pHandler, exception, pShadowFrame);
            }

            return DispatchContinueSearch(exception, pDispatchData);
        }

        private static void HandleExceptionWasmFault(void* pShadowFrame, DispatchData* pDispatchData, void* pHandler)
        {
            // TODO-LLVM-EH: for compatiblity with the IL backend we will invoke faults/finallys even if we do not find
            // a suitable catch in a frame. A correct implementation of this will require us to keep a stack of pending
            // faults/finallys (inside the native exception), to be invoked at the point we find the handling frame. We
            // should also fail fast instead of invoking the second pass handlers if the exception goes unhandled.
            //
            object exception = BeginSingleDispatch(RhEHClauseKind.RH_EH_CLAUSE_FAULT, null, pShadowFrame, pDispatchData);
            CallFinallyFunclet(pHandler, pShadowFrame, ryuJitAbi: true);
            DispatchContinueSearch(exception, pDispatchData);
        }

        private static object BeginSingleDispatch(RhEHClauseKind kind, void* data, void* pShadowFrame, DispatchData* pDispatchData)
        {
            // The managed exception is passed around in the native one, and if we take a GC before retrieving it,
            // it will get invalidated. See also the TODO-LLVM-EH above; we should address this in a more robust way.
            InternalCalls.RhpSetThreadDoNotTriggerGC();

            ManagedExceptionWrapper* pCppException;
            bool isActive = pDispatchData->Active;
            if (!isActive)
            {
                pCppException = (ManagedExceptionWrapper*)__cxa_begin_catch(pDispatchData->CppExceptionTuple.ExceptionData);
                pDispatchData->DispatcherData = pCppException;
            }
            else
            {
                pCppException = pDispatchData->DispatcherData;
            }

            object exception = Unsafe.Read<object>(&pCppException->ManagedException);
            InternalCalls.RhpClearThreadDoNotTriggerGC();

            WasmEHLogDispatcherEnter(kind, data, pShadowFrame, isActive);

            return exception;
        }

        private static int DispatchContinueSearch(object exception, DispatchData* pDispatchData)
        {
            // GC may have invalidated the exception object in the native exception; make sure it is up-to-date before
            // rethrowing or jumping to an upstream dispatcher.
            fixed (void* pKeepAlive = &exception.GetRawData())
            {
                Unsafe.Write(&pDispatchData->DispatcherData->ManagedException, exception);
            }

            return 0;
        }

        [DllImport("*"), SuppressGCTransition]
        private static extern byte* __cxa_begin_catch(void* pExceptionData);

        [DllImport("*"), SuppressGCTransition]
        private static extern void __cxa_end_catch();

        [DllImport("*")]
        private static extern void RhpThrowEx(void* exception);

        [RuntimeExport("RhpRethrow")]
        private static void RhpRethrow(void** pException) // TODO-LLVM: use object* once C#11 is available.
        {
            Exception.DispatchExLLVM(Unsafe.Read<object>(pException));
            RhpThrowEx(*pException); // GC hole...
        }

        // The below two handlers are invoked by LLVM code generated via the IL backend.
        //
        internal struct RhEHClauseWasm
        {
            internal uint _tryStartOffset;
            internal EHClauseIterator.RhEHClauseKindWasm _clauseKind;
            internal uint _tryEndOffset;
            internal uint _typeSymbol;
            internal byte* _handlerAddress;
            internal byte* _filterAddress;

            public bool ContainsCodeOffset(uint idxTryLandingStart)
            {
                return (idxTryLandingStart >= _tryStartOffset) && (idxTryLandingStart < _tryEndOffset);
            }
        }

        private static bool FindFirstPassHandlerWasm(object exception, uint idxStart, uint idxCurrentBlockStart /* the start IL idx of the current block for the landing pad, will use in place of PC */,
            void* shadowStack, ref EHClauseIterator clauseIter, out uint tryRegionIdx, out byte* pHandler)
        {
            WasmEHLogFirstPassEnter(exception, idxCurrentBlockStart, shadowStack);

            pHandler = null;
            tryRegionIdx = MaxTryRegionIdx;

            uint lastTryStart = 0, lastTryEnd = 0;
            RhEHClauseWasm ehClause = new RhEHClauseWasm();
            for (uint curIdx = 0; clauseIter.Next(ref ehClause); curIdx++)
            {
                WasmEHLogEHInfoEntry(&ehClause, curIdx, "1", shadowStack);
                //
                // Skip to the starting try region.  This is used by collided unwinds and rethrows to pickup where
                // the previous dispatch left off.
                //
                if (idxStart != MaxTryRegionIdx)
                {
                    if (curIdx <= idxStart)
                    {
                        lastTryStart = ehClause._tryStartOffset;
                        lastTryEnd = ehClause._tryEndOffset;
                        continue;
                    }

                    // Now, we continue skipping while the try region is identical to the one that invoked the
                    // previous dispatch.
                    if ((ehClause._tryStartOffset == lastTryStart) && (ehClause._tryEndOffset == lastTryEnd))
                    {
                        continue;
                    }

                    // We are done skipping. This is required to handle empty finally block markers that are used
                    // to separate runs of different try blocks with same native code offsets.
                    idxStart = MaxTryRegionIdx;
                }

                EHClauseIterator.RhEHClauseKindWasm clauseKind = ehClause._clauseKind;
                if (((clauseKind != EHClauseIterator.RhEHClauseKindWasm.RH_EH_CLAUSE_TYPED) &&
                     (clauseKind != EHClauseIterator.RhEHClauseKindWasm.RH_EH_CLAUSE_FILTER))
                    || !ehClause.ContainsCodeOffset(idxCurrentBlockStart))
                {
                    continue;
                }

                // Found a containing clause. Because of the order of the clauses, we know this is the
                // most containing.
                if (clauseKind == EHClauseIterator.RhEHClauseKindWasm.RH_EH_CLAUSE_TYPED)
                {
                    if (ShouldTypedClauseCatchThisException(exception, (MethodTable*)ehClause._typeSymbol))
                    {
                        pHandler = ehClause._handlerAddress;
                        tryRegionIdx = curIdx;

                        WasmEHLogFirstPassExit(pHandler, shadowStack);
                        return true;
                    }
                }
                else
                {
                    bool shouldInvokeHandler = CallFilterFunclet(ehClause._filterAddress, exception, shadowStack, ryuJitAbi: false);
                    if (shouldInvokeHandler)
                    {
                        pHandler = ehClause._handlerAddress;
                        tryRegionIdx = curIdx;

                        WasmEHLogFirstPassExit(pHandler, shadowStack);
                        return true;
                    }
                }
            }

            WasmEHLogFirstPassExit(null, shadowStack);
            return false;
        }

        private static void InvokeSecondPassWasm(uint idxStart, uint idxTryLandingStart /* we do dont have the PC, so use the start of the block */,
            ref EHClauseIterator clauseIter, uint idxLimit, void* shadowStack)
        {
            // Search the clauses for one that contains the current offset.
            RhEHClauseWasm ehClause = new RhEHClauseWasm();
            for (uint curIdx = 0; clauseIter.Next(ref ehClause) && curIdx < idxLimit; curIdx++)
            {
                if (curIdx > idxStart)
                {
                    break; // these blocks are after the catch
                }

                EHClauseIterator.RhEHClauseKindWasm clauseKind = ehClause._clauseKind;

                if ((clauseKind != EHClauseIterator.RhEHClauseKindWasm.RH_EH_CLAUSE_FAULT)
                    || !ehClause.ContainsCodeOffset(idxTryLandingStart))
                {
                    continue;
                }

                // Found a containing clause. Because of the order of the clauses, we know this is the
                // most containing.
                CallFinallyFunclet(ehClause._handlerAddress, shadowStack, ryuJitAbi: false);
            }
        }

        private static int CallCatchFunclet(void* pFunclet, object exception, void* pShadowFrame)
        {
            // IL backend invokes the catch handler in generated code.
            WasmEHLogFunletEnter(pFunclet, RhEHClauseKind.RH_EH_CLAUSE_TYPED, pShadowFrame, ryuJitAbi: true);
            int catchRetIdx = ((delegate*<object, void*, int>)pFunclet)(exception, pShadowFrame);
            WasmEHLogFunletExit(RhEHClauseKind.RH_EH_CLAUSE_TYPED, catchRetIdx, pShadowFrame, ryuJitAbi: true);

            return catchRetIdx;
        }

        private static bool CallFilterFunclet(void* pFunclet, object exception, void* pShadowFrame, bool ryuJitAbi)
        {
            bool result;
            WasmEHLogFunletEnter(pFunclet, RhEHClauseKind.RH_EH_CLAUSE_FILTER, pShadowFrame, ryuJitAbi);
            if (ryuJitAbi)
            {
                result = ((delegate*<object, void*, int>)pFunclet)(exception, pShadowFrame) != 0;
            }
            else
            {
                result = InternalCalls.RhpCallFilterFunclet(exception, (byte*)pFunclet, pShadowFrame);
            }
            WasmEHLogFunletExit(RhEHClauseKind.RH_EH_CLAUSE_FILTER, result ? 1 : 0, pShadowFrame, ryuJitAbi);

            return result;
        }

        private static void CallFinallyFunclet(void* pFunclet, void* pShadowFrame, bool ryuJitAbi)
        {
            WasmEHLogFunletEnter(pFunclet, RhEHClauseKind.RH_EH_CLAUSE_FAULT, pShadowFrame, ryuJitAbi);
            if (ryuJitAbi)
            {
                ((delegate*<void*, void>)pFunclet)(pShadowFrame);
            }
            else
            {
                InternalCalls.RhpCallFinallyFunclet((byte*)pFunclet, pShadowFrame);
            }
            WasmEHLogFunletExit(RhEHClauseKind.RH_EH_CLAUSE_FAULT, 0, pShadowFrame, ryuJitAbi);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLog(string message, void* pShadowFrame, string pass, bool ryuJitAbi)
        {
            string log = "WASM EH/" + (ryuJitAbi ? "RyuJit" : "IL");
            log += " [SF: " + ToHex(pShadowFrame) + "]";
            log += " [" + pass + "]";
            log += ": " + message + Environment.NewLineConst;

            byte[] bytes = new byte[log.Length + 1];
            for (int i = 0; i < log.Length; i++)
            {
                bytes[i] = (byte)log[i];
            }

            fixed (byte* p = bytes)
            {
                Interop.Sys.Log(p, bytes.Length);
            }
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogDispatcherEnter(RhEHClauseKind kind, void* data, void* pShadowFrame, bool isActive)
        {
            string description = GetClauseDescription(kind, data);
            string pass = kind == RhEHClauseKind.RH_EH_CLAUSE_FAULT ? "2" : "1";
            WasmEHLog("Handling" + (isActive ? " (active)" : "") + ": " + description, pShadowFrame, pass, ryuJitAbi: true);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogEHTableEntry(EHRyuJitClauseWasm clause, void* pShadowFrame)
        {
            string description = clause.Filter != null ? GetClauseDescription(RhEHClauseKind.RH_EH_CLAUSE_FILTER, clause.Filter)
                                                       : GetClauseDescription(RhEHClauseKind.RH_EH_CLAUSE_TYPED, clause.ClauseType);
            WasmEHLog("Clause: " + description, pShadowFrame, "1", ryuJitAbi: true);
        }

        private static string GetClauseDescription(RhEHClauseKind kind, void* data) => kind switch
        {
            RhEHClauseKind.RH_EH_CLAUSE_TYPED => "catch, class [" + new RuntimeTypeHandle(new EETypePtr((MethodTable*)data)).LastResortToString + "]",
            RhEHClauseKind.RH_EH_CLAUSE_FILTER => "filtered catch",
            RhEHClauseKind.RH_EH_CLAUSE_UNUSED => "mutually protecting catches, table at [" + ToHex(data) + "]",
            _ => "fault",
        };

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogFunletEnter(void* pHandler, RhEHClauseKind kind, void* pShadowFrame, bool ryuJitAbi)
        {
            (string name, string pass) = kind switch
            {
                RhEHClauseKind.RH_EH_CLAUSE_FILTER => ("filter", "1"),
                RhEHClauseKind.RH_EH_CLAUSE_FAULT => ("fault", "2"),
                _ => ("catch", "2")
            };

            WasmEHLog("Calling " + name + " funclet at [" + ToHex(pHandler) + "]", pShadowFrame, pass, ryuJitAbi);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogFunletExit(RhEHClauseKind kind, int result, void* pShadowFrame, bool ryuJitAbi)
        {
            (string resultString, string pass) = kind switch
            {
                RhEHClauseKind.RH_EH_CLAUSE_FILTER => (result == 1 ? "true" : "false", "1"),
                RhEHClauseKind.RH_EH_CLAUSE_FAULT => ("success", "2"),
                _ => (ToHex(result), "2")
            };

            WasmEHLog("Funclet returned: " + resultString, pShadowFrame, pass, ryuJitAbi);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogFirstPassEnter(object exception, uint codeIdx, void* pShadowFrame)
        {
            WasmEHLog("Pass start; at: " + ToHex(codeIdx) + ", exception: [" + exception.GetTypeHandle().LastResortToString + "]",
                pShadowFrame, "1", ryuJitAbi: false);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogFirstPassExit(void* pHandler, void* pShadowFrame)
        {
            WasmEHLog("Pass end; handler " + (pHandler != null ? "found at [" + ToHex(pHandler) + "]" : "not found"),
                pShadowFrame, "1", ryuJitAbi: false);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogEHInfoEntry(RhEHClauseWasm* pClause, uint index, string pass, void* pShadowFrame)
        {
            string tryBeg = ToHex(pClause->_tryStartOffset);
            string tryEnd = ToHex(pClause->_tryEndOffset);
            string hndAddr = ToHex(pClause->_handlerAddress);
            string log = "EH#" + ToHex(index) + ": try [" + tryBeg + ".." + tryEnd + ") handled by [" + hndAddr + "]";

            switch (pClause->_clauseKind)
            {
                case EHClauseIterator.RhEHClauseKindWasm.RH_EH_CLAUSE_FILTER:
                    log += ", filter at [" + ToHex(pClause->_filterAddress) + "]";
                    break;
                case EHClauseIterator.RhEHClauseKindWasm.RH_EH_CLAUSE_TYPED:
                    log += ", class [" + new RuntimeTypeHandle(new EETypePtr((MethodTable*)pClause->_typeSymbol)).LastResortToString + "]";
                    break;
                case EHClauseIterator.RhEHClauseKindWasm.RH_EH_CLAUSE_FAULT:
                    log += ", fault";
                    break;
                default:
                    log += ", unknown?!";
                    break;
            }

            WasmEHLog(log, pShadowFrame, pass, ryuJitAbi: false);
        }

        private static string ToHex(uint value) => ToHex((int)value);
        private static string ToHex(void* value) => "0x" + ToHex((nint)value);

        private static string ToHex(nint value)
        {
            int length = 2 * sizeof(nint);
            char* chars = stackalloc char[length];
            for (int i = length - 1, j = 0; j < length; i--, j++)
            {
                chars[j] = "0123456789ABCDEF"[(int)((value >> (i * 4)) & 0xF)];
            }

            return new string(chars, 0, length);
        }
    }
}
