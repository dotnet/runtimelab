// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

using Internal.Runtime;

namespace System.Runtime
{
    internal static unsafe partial class EH
    {
        // The layout of this struct must match the native version in "Bootstrapper/main.cpp" exactly.
        [StructLayout(LayoutKind.Explicit)]
        private struct ManagedExceptionWrapper
        {
            // TODO-LLVM: update the field to be typed "object" once C#11 is available.
            // TODO-LLVM-EH: the way managed exception object is being passed inside the native exception is a GC hole.
            // Make this more robust, e. g. wrap it in a GCHandle.
            // TODO-LLVM: make the offset into a constant generated by the runtime build (ala AsmOffsets.cs).
            [FieldOffset(4)]
            public void* ManagedException;
        }

        // The layout of this struct must match what codegen expects (see "jit/llvmcodegen.cpp, generateEHDispatch").
        // Instances of it are shared between dispatchers across a single native frame.
        private struct DispatchData
        {
            public readonly CppExceptionTuple CppExceptionTuple; // Owned by codegen.
            public ManagedExceptionWrapper* DispatcherData; // Owned by runtime.

            // We consider a dispatch to be "active" if it has already visited nested handlers in the same LLVM frame.
            // Codegen will initialize "DispatcherData" to null on entry to the native handler.
            public bool Active => DispatcherData != null;
        }

        private struct CppExceptionTuple
        {
            public void* ExceptionData;
            public int Selector;
        }

        // These per-clause handlers are invoked by RyuJit-generated LLVM code.
        //
        private static int HandleExceptionWasmMutuallyProtectingCatches(void* pShadowFrame, DispatchData* pDispatchData, void** pEHTable)
        {
            object exception = BeginSingleDispatch(RhEHClauseKind.RH_EH_CLAUSE_UNUSED, pEHTable, pShadowFrame, pDispatchData);

            EHClauseIteratorWasm clauseIter = new EHClauseIteratorWasm(pEHTable);
            EHClauseWasm clause;
            while (clauseIter.Next(&clause))
            {
                WasmEHLogEHTableEntry(clause, pShadowFrame);

                bool foundHandler = false;
                if (clause.Filter != null)
                {
                    if (CallFilterFunclet(clause.Filter, exception, pShadowFrame))
                    {
                        foundHandler = true;
                    }
                }
                else
                {
                    if (ShouldTypedClauseCatchThisException(exception, clause.ClauseType))
                    {
                        foundHandler = true;
                    }
                }

                if (foundHandler)
                {
                    __cxa_end_catch();
                    return CallCatchFunclet(clause.Handler, exception, pShadowFrame);
                }
            }

            return DispatchContinueSearch(exception, pDispatchData);
        }

        private static int HandleExceptionWasmFilteredCatch(void* pShadowFrame, DispatchData* pDispatchData, void* pHandler, void* pFilter)
        {
            object exception = BeginSingleDispatch(RhEHClauseKind.RH_EH_CLAUSE_FILTER, null, pShadowFrame, pDispatchData);

            if (CallFilterFunclet(pFilter, exception, pShadowFrame))
            {
                __cxa_end_catch();
                return CallCatchFunclet(pHandler, exception, pShadowFrame);
            }

            return DispatchContinueSearch(exception, pDispatchData);
        }

        private static int HandleExceptionWasmCatch(void* pShadowFrame, DispatchData* pDispatchData, void* pHandler, MethodTable* pClauseType)
        {
            object exception = BeginSingleDispatch(RhEHClauseKind.RH_EH_CLAUSE_TYPED, pClauseType, pShadowFrame, pDispatchData);

            if (ShouldTypedClauseCatchThisException(exception, pClauseType))
            {
                __cxa_end_catch();
                return CallCatchFunclet(pHandler, exception, pShadowFrame);
            }

            return DispatchContinueSearch(exception, pDispatchData);
        }

        private static void HandleExceptionWasmFault(void* pShadowFrame, DispatchData* pDispatchData, void* pHandler)
        {
            // TODO-LLVM-EH: we invoke faults/finallys even if we do not find a suitable catch in a frame. A correct
            // implementation of this will require us to keep a stack of pending faults/finallys (inside the native
            // exception), to be invoked at the point we find the handling frame. We should also fail fast instead
            // of invoking the second pass handlers if the exception goes unhandled.
            //
            object exception = BeginSingleDispatch(RhEHClauseKind.RH_EH_CLAUSE_FAULT, null, pShadowFrame, pDispatchData);
            CallFinallyFunclet(pHandler, pShadowFrame);
            DispatchContinueSearch(exception, pDispatchData);
        }

        private static object BeginSingleDispatch(RhEHClauseKind kind, void* data, void* pShadowFrame, DispatchData* pDispatchData)
        {
            // The managed exception is passed around in the native one, and if we take a GC before retrieving it,
            // it will get invalidated. See also the TODO-LLVM-EH above; we should address this in a more robust way.
            InternalCalls.RhpSetThreadDoNotTriggerGC();

            ManagedExceptionWrapper* pCppException;
            bool isActive = pDispatchData->Active;
            if (!isActive)
            {
                pCppException = (ManagedExceptionWrapper*)__cxa_begin_catch(pDispatchData->CppExceptionTuple.ExceptionData);
                pDispatchData->DispatcherData = pCppException;
            }
            else
            {
                pCppException = pDispatchData->DispatcherData;
            }

            object exception = Unsafe.Read<object>(&pCppException->ManagedException);
            InternalCalls.RhpClearThreadDoNotTriggerGC();

            WasmEHLogDispatcherEnter(kind, data, pShadowFrame, isActive);

            return exception;
        }

        private static int DispatchContinueSearch(object exception, DispatchData* pDispatchData)
        {
            // GC may have invalidated the exception object in the native exception; make sure it is up-to-date before
            // rethrowing or jumping to an upstream dispatcher.
            fixed (void* pKeepAlive = &exception.GetRawData())
            {
                Unsafe.Write(&pDispatchData->DispatcherData->ManagedException, exception);
            }

            return 0;
        }

        [LibraryImport("*"), SuppressGCTransition]
        private static partial byte* __cxa_begin_catch(void* pExceptionData);

        [LibraryImport("*"), SuppressGCTransition]
        private static partial void __cxa_end_catch();

        [RuntimeExport("RhpThrowEx")]
        private static void RhpThrowEx(object exception)
        {
#if INPLACE_RUNTIME
            // Turn "throw null" into "throw new NullReferenceException()".
            exception ??= new NullReferenceException();
#endif
            Exception.DispatchExLLVM(exception);
            InternalCalls.RhpThrowNativeException(exception);
        }

        [RuntimeExport("RhpRethrow")]
        private static void RhpRethrow(void** pException) // TODO-LLVM: update to be typed "object*" once C#11 is available.
        {
            RhpThrowEx(Unsafe.Read<object>(pException));
        }

        private static int CallCatchFunclet(void* pFunclet, object exception, void* pShadowFrame)
        {
            // IL backend invokes the catch handler in generated code.
            WasmEHLogFunletEnter(pFunclet, RhEHClauseKind.RH_EH_CLAUSE_TYPED, pShadowFrame);
            int catchRetIdx = ((delegate*<object, void*, int>)pFunclet)(exception, pShadowFrame);
            WasmEHLogFunletExit(RhEHClauseKind.RH_EH_CLAUSE_TYPED, catchRetIdx, pShadowFrame);

            return catchRetIdx;
        }

        private static bool CallFilterFunclet(void* pFunclet, object exception, void* pShadowFrame)
        {
            WasmEHLogFunletEnter(pFunclet, RhEHClauseKind.RH_EH_CLAUSE_FILTER, pShadowFrame);
            bool result = ((delegate*<object, void*, int>)pFunclet)(exception, pShadowFrame) != 0;
            WasmEHLogFunletExit(RhEHClauseKind.RH_EH_CLAUSE_FILTER, result ? 1 : 0, pShadowFrame);

            return result;
        }

        private static void CallFinallyFunclet(void* pFunclet, void* pShadowFrame)
        {
            WasmEHLogFunletEnter(pFunclet, RhEHClauseKind.RH_EH_CLAUSE_FAULT, pShadowFrame);
            ((delegate*<void*, void>)pFunclet)(pShadowFrame);
            WasmEHLogFunletExit(RhEHClauseKind.RH_EH_CLAUSE_FAULT, 0, pShadowFrame);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLog(string message, void* pShadowFrame, string pass)
        {
            string log = "WASM EH";
            log += " [SF: " + ToHex(pShadowFrame) + "]";
            log += " [" + pass + "]";
            log += ": " + message + Environment.NewLineConst;

            byte[] bytes = new byte[log.Length + 1];
            for (int i = 0; i < log.Length; i++)
            {
                bytes[i] = (byte)log[i];
            }

            fixed (byte* p = bytes)
            {
                Interop.Sys.Log(p, bytes.Length);
            }
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogDispatcherEnter(RhEHClauseKind kind, void* data, void* pShadowFrame, bool isActive)
        {
            string description = GetClauseDescription(kind, data);
            string pass = kind == RhEHClauseKind.RH_EH_CLAUSE_FAULT ? "2" : "1";
            WasmEHLog("Handling" + (isActive ? " (active)" : "") + ": " + description, pShadowFrame, pass);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogEHTableEntry(EHClauseWasm clause, void* pShadowFrame)
        {
            string description = clause.Filter != null ? GetClauseDescription(RhEHClauseKind.RH_EH_CLAUSE_FILTER, clause.Filter)
                                                       : GetClauseDescription(RhEHClauseKind.RH_EH_CLAUSE_TYPED, clause.ClauseType);
            WasmEHLog("Clause: " + description, pShadowFrame, "1");
        }

        private static string GetClauseDescription(RhEHClauseKind kind, void* data) => kind switch
        {
            RhEHClauseKind.RH_EH_CLAUSE_TYPED => "catch, class [" + new RuntimeTypeHandle(new EETypePtr((MethodTable*)data)).LastResortToString + "]",
            RhEHClauseKind.RH_EH_CLAUSE_FILTER => "filtered catch",
            RhEHClauseKind.RH_EH_CLAUSE_UNUSED => "mutually protecting catches, table at [" + ToHex(data) + "]",
            _ => "fault",
        };

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogFunletEnter(void* pHandler, RhEHClauseKind kind, void* pShadowFrame)
        {
            (string name, string pass) = kind switch
            {
                RhEHClauseKind.RH_EH_CLAUSE_FILTER => ("filter", "1"),
                RhEHClauseKind.RH_EH_CLAUSE_FAULT => ("fault", "2"),
                _ => ("catch", "2")
            };

            WasmEHLog("Calling " + name + " funclet at [" + ToHex(pHandler) + "]", pShadowFrame, pass);
        }

        [Conditional("ENABLE_NOISY_WASM_EH_LOG")]
        private static void WasmEHLogFunletExit(RhEHClauseKind kind, int result, void* pShadowFrame)
        {
            (string resultString, string pass) = kind switch
            {
                RhEHClauseKind.RH_EH_CLAUSE_FILTER => (result == 1 ? "true" : "false", "1"),
                RhEHClauseKind.RH_EH_CLAUSE_FAULT => ("success", "2"),
                _ => (ToHex(result), "2")
            };

            WasmEHLog("Funclet returned: " + resultString, pShadowFrame, pass);
        }

        private static string ToHex(uint value) => ToHex((int)value);
        private static string ToHex(void* value) => "0x" + ToHex((nint)value);

        private static string ToHex(nint value)
        {
            int length = 2 * sizeof(nint);
            char* chars = stackalloc char[length];
            for (int i = length - 1, j = 0; j < length; i--, j++)
            {
                chars[j] = "0123456789ABCDEF"[(int)((value >> (i * 4)) & 0xF)];
            }

            return new string(chars, 0, length);
        }

        // This iterator is used for EH tables produces by codegen for runs of mutually protecting catch handlers.
        //
        internal unsafe struct EHClauseWasm
        {
            public void* Handler;
            public void* Filter;
            public MethodTable* ClauseType;
        }

        // See codegen code ("jit/llvmcodegen.cpp, generateEHDispatchTable") for details on the format of the table.
        //
        internal unsafe struct EHClauseIteratorWasm
        {
            private const nuint HeaderRecordSize = 1;
            private const nuint ClauseRecordSize = 2;
            private static nuint FirstSectionSize => HeaderRecordSize + (nuint)sizeof(nuint) / 2 * 8 * ClauseRecordSize;
            private static nuint LargeSectionSize => HeaderRecordSize + (nuint)sizeof(nuint) * 8 * ClauseRecordSize;

            private readonly void** _pTableEnd;
            private void** _pCurrentSectionClauses;
            private void** _pNextSection;
            private nuint _currentIndex;
            private nuint _clauseKindMask;

            public EHClauseIteratorWasm(void** pEHTable)
            {
                _pCurrentSectionClauses = pEHTable + HeaderRecordSize;
                _pNextSection = pEHTable + FirstSectionSize;
                _currentIndex = 0;
#if TARGET_32BIT
                _clauseKindMask = ((ushort*)pEHTable)[1];
                nuint tableSize = ((ushort*)pEHTable)[0];
#else
                _clauseKindMask = ((uint*)pEHTable)[1];
                nuint tableSize = ((uint*)pEHTable)[0];
#endif
                _pTableEnd = pEHTable + tableSize;
            }

            public bool Next(EHClauseWasm* pClause)
            {
                void** pCurrent = _pCurrentSectionClauses + _currentIndex * ClauseRecordSize;
                if (pCurrent >= _pTableEnd)
                {
                    return false;
                }

                if ((_clauseKindMask & ((nuint)1 << (int)_currentIndex)) != 0)
                {
                    pClause->Filter = pCurrent[0];
                    pClause->ClauseType = null;
                }
                else
                {
                    pClause->Filter = null;
                    pClause->ClauseType = (MethodTable*)pCurrent[0];
                }

                pClause->Handler = pCurrent[1];

                // Initialize the state for the next iteration.
                void** pCurrentNext = pCurrent + ClauseRecordSize;
                if ((pCurrentNext != _pTableEnd) && (pCurrentNext == _pNextSection))
                {
                    _pCurrentSectionClauses = pCurrentNext + HeaderRecordSize;
                    _pNextSection += LargeSectionSize;
                    _currentIndex = 0;
                    _clauseKindMask = (nuint)pCurrentNext[0];
                }
                else
                {
                    _currentIndex++;
                }

                return true;
            }
        }
    }
}
