// Licensed to the .NET Foundation under one or more agreements.
// The.NET Foundation licenses this file to you under the MIT license.
//
// <auto-generated />
//

using System.Diagnostics;
using System.Threading.Tasks;

namespace System.Runtime.InteropServices.JavaScript
{
    //
    // This class is included directly into user code to simplify the implementation of the source
    // generator and reuse all of the handling that already exists for JSExport-attributed methods.
    //
    internal static partial class GeneratedAsyncEntryPointThunkClass
    {
        private const int None = 0;
        private const int Args = 1;
        private const int Int = 2;
        private const int TaskOfVoid = 3;
        private const int TaskOfInt = 4;

        [JSExport] // Keep the signature in sync with "JSHostImplementation.CallEntrypoint".
        private static unsafe Task<int> AsyncEntryPointThunk(nint assemblyNamePtr, string[] args, bool waitForDebugger)
        {
            void* pEntryPoint = null;
            int sigRetType = None;
            int sigArgsType = None;
            GetEntryPointInfo(&pEntryPoint, &sigRetType, &sigArgsType);
            if (pEntryPoint == null)
            {
                Environment.FailFast("Could not acquire the entrypoint.");
            }

            try
            {
                switch (sigRetType)
                {
                    default:
                        Debug.Assert(sigRetType == None);
                        if (sigArgsType == Args)
                        {
                            ((delegate*<string[], void>)pEntryPoint)(args);
                        }
                        else
                        {
                            ((delegate*<void>)pEntryPoint)();
                        }
                        return Task.FromResult(0);

                    case Int:
                        int exitCode;
                        if (sigArgsType == Args)
                        {
                            exitCode = ((delegate*<string[], int>)pEntryPoint)(args);
                        }
                        else
                        {
                            exitCode = ((delegate*<int>)pEntryPoint)();
                        }
                        return Task.FromResult(exitCode);

                    case TaskOfVoid:
                        Task task;
                        if (sigArgsType == Args)
                        {
                            task = ((delegate*<string[], Task>)pEntryPoint)(args);
                        }
                        else
                        {
                            task = ((delegate*<Task>)pEntryPoint)();
                        }

                        TaskCompletionSource<int> tcs = new TaskCompletionSource<int>();
                        task.ContinueWith(t =>
                        {
                            if (t.IsFaulted)
                            {
                                tcs.SetException(t.Exception);
                            }
                            else
                            {
                                tcs.SetResult(0);
                            }
                        }, TaskScheduler.Default);
                        return tcs.Task;

                    case TaskOfInt:
                        if (sigArgsType == Args)
                        {
                            return ((delegate*<string[], Task<int>>)pEntryPoint)(args);
                        }
                        else
                        {
                            return ((delegate*<Task<int>>)pEntryPoint)();
                        }
                }
            }
            catch (Exception e)
            {
                return Task.FromException<int>(e);
            }
        }

        // The real implementation will be provided by the source generator and preferred over this one by overload resolution.
        private static unsafe void GetEntryPointInfo(void** pEntryPoint, int* sigRetType, int* sigArgsType, int _ = 0) { }
    }
}
