// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Generic;

using ILCompiler.DependencyAnalysisFramework;

using Internal.IL;
using Internal.Text;
using Internal.TypeSystem;

using Debug = System.Diagnostics.Debug;

namespace ILCompiler.DependencyAnalysis
{
    /// <summary>
    /// Represents a stand-in for a real method body that can turn into the real method
    /// body at object emission phase if the real method body was marked.
    /// This node conditionally depends on the real method body - the real method body
    /// will be brough into compilation if the owning type was marked.
    /// This operates under the assumption that instance methods don't get called with
    /// a null `this`. While it's possible to call instance methods with a null `this`,
    /// there are many reasons why it's a bad idea (C# language assumes `this` can never be null;
    /// generically shared native code generated by this compiler assumes `this` is not null and
    /// we can get the generic dictionary out of it, etc.).
    /// </summary>
    partial class TentativeInstanceMethodNode : AssemblyStubNode, IMethodNode, ISymbolNodeWithLinkage
    {
        private readonly IMethodBodyNode _methodNode;

        public IMethodBodyNode RealBody => _methodNode;

        public TentativeInstanceMethodNode(IMethodBodyNode methodNode)
        {
            Debug.Assert(!methodNode.Method.Signature.IsStatic);
            Debug.Assert(!methodNode.Method.OwningType.IsValueType);
            _methodNode = methodNode;
        }

        private ISymbolNode GetTarget(NodeFactory factory)
        {
            // TODO: Make a new entrypoint?
            MethodDesc helper = factory.TypeSystemContext.GetHelperEntryPoint("ThrowHelpers", "ThrowBodyRemoved");
            return factory.MethodEntrypoint(helper);
        }

        public MethodDesc Method => _methodNode.Method;

        public override IEnumerable<CombinedDependencyListEntry> GetConditionalStaticDependencies(NodeFactory factory)
        {
            // Convert methods on Array<T> into T[]
            TypeDesc owningType = _methodNode.Method.OwningType;
            if (owningType.HasSameTypeDefinition(factory.ArrayOfTClass))
            {
                owningType = owningType.Instantiation[0].MakeArrayType();
            }

            // If a constructed symbol for the owning type was included in the compilation,
            // include the real method body.
            return new CombinedDependencyListEntry[]
            {
                new CombinedDependencyListEntry(
                    _methodNode,
                    factory.ConstructedTypeSymbol(owningType),
                    "Instance method on a constructed type"),
            };
        }

        protected override string GetName(NodeFactory factory)
        {
            return "Tentative instance method: " + _methodNode.GetMangledName(factory.NameMangler);
        }

        public override bool ShouldSkipEmittingObjectNode(NodeFactory factory)
        {
            // If the real body was marked, don't emit this assembly stub.
            return _methodNode.Marked;
        }

        public override IEnumerable<CombinedDependencyListEntry> SearchDynamicDependencies(List<DependencyNodeCore<NodeFactory>> markedNodes, int firstNode, NodeFactory context) => null;
        public override bool InterestingForDynamicDependencyAnalysis => false;
        public override bool HasDynamicDependencies => false;
        public override bool HasConditionalStaticDependencies => true;

        public override void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb)
        {
            // We use the same mangled name as the underlying real method body.
            // This is okay since this node will go out of the way if the real body is marked
            // and part of the graph.
            _methodNode.AppendMangledName(nameMangler, sb);
        }

        public override int CompareToImpl(ISortableNode other, CompilerComparer comparer)
        {
            return _methodNode.CompareToImpl(((TentativeInstanceMethodNode)other)._methodNode, comparer);
        }

        public ISymbolNode NodeForLinkage(NodeFactory factory)
        {
            // If someone refers to this node but the real method was marked, emit relocs to this
            // as relocs to the real method.
            return _methodNode.Marked ? _methodNode : (ISymbolNode)this;
        }

        public override bool RepresentsIndirectionCell
        {
            get
            {
                Debug.Assert(!_methodNode.RepresentsIndirectionCell);
                return false;
            }
        }

        public override int ClassCode => 0x562912;

        public override bool IsShareable => ((ObjectNode)_methodNode).IsShareable;
    }
}
